% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict_average.R
\name{predict_average}
\alias{predict_average}
\title{Use averages to impute and forecast data}
\usage{
predict_average(
  df,
  col = "value",
  average_cols = NULL,
  flat_extrap = TRUE,
  ret = c("df", "all", "error"),
  test_col = NULL,
  group_col = NULL,
  sort_col = NULL,
  sort_descending = FALSE,
  pred_col = "pred",
  type_col = NULL,
  types = c("imputed", "imputed", "projected"),
  source_col = NULL,
  source = NULL,
  replace_obs = c("missing", "all", "none")
)
}
\arguments{
\item{df}{Data frame of model data.}

\item{col}{Name of column to extrapolate/interpolate.}

\item{average_cols}{Column name(s) of column(s) for use in grouping data for averaging,
such as regions. If missing, uses global average of the data for infilling.}

\item{flat_extrap}{Logical value determining whether or not to flat extrapolate
using the latest average for missing rows with no data available.}

\item{ret}{Character vector specifying what values the function returns. Defaults
to returning a data frame, but can return a vector of model error, the
model itself or a list with all 3 as components.}

\item{test_col}{Name of logical column specifying which response values to remove
for testing the model's predictive accuracy. If \code{NULL}, ignored.}

\item{group_col}{Column name(s) of group(s) to use in \code{\link[dplyr:group_by]{dplyr::group_by()}} when
supplying type, calculating mean absolute scaled error on data involving
time series, and if \code{group_models}, then fitting and predicting models too.}

\item{sort_col}{Column name(s) to use to \code{\link[dplyr:arrange]{dplyr::arrange()}} the data prior to
supplying type and calculating mean absolute scaled error on data involving
time series.}

\item{sort_descending}{Logical value on whether the sorted values from \code{sort_col}
should be sorted in descending order. Defaults to \code{FALSE}.}

\item{pred_col}{Column name to store predicted value.}

\item{type_col}{Column name specifying data type.}

\item{types}{Vector of length 3 that provides the type to provide to data
produced in the model. These values are only used to fill in type values
where the dependent variable is missing. The first value is given to missing
observations that precede the first observation, the second to those after
the last observation, and the third for those following the final observation.}

\item{source_col}{Column name containing source information for the data frame.
If provided, the argument in \code{source} is used to fill in where predictions
have filled in missing data.}

\item{source}{Source to add to missing values.}

\item{replace_obs}{Character value specifying how, if at all, observations should
be replaced by infilled values. By default, replaces missing values in \code{col}
but if set to \code{"none"} then \code{col} is not changed.}
}
\value{
Depending on the value passed to \code{ret}, either a data frame with
predicted data, a vector of errors, a fitted model, or a list with all 3.
}
\description{
\code{predict_average()} does simple infilling and prediction using averages.
Similar to other predict functions, it also allows filling in of type and source
if necessary. However, it does not provide confidence bounds on the estimates,
like other \code{predict_...} model-based functions provide.
}
\details{
For each year where at least 1 data point is available, the average is calculated
as the prediction. If \code{flat_extrap}, then the latest average is flat extrapolated
to the end of the data. When using \code{test_col}, the average may not be available
for certain groups, so flat extrapolation will be relied on, meaning that the
\code{COR} metric output by errors is difficult to interpret or use proplery and it will
generate warnings about a standard deviation of zero.
}
