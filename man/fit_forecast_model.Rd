% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict_forecast.R
\name{fit_forecast_model}
\alias{fit_forecast_model}
\title{Fit forecast model to data}
\usage{
fit_forecast_model(
  df,
  forecast_function,
  response,
  ...,
  test_col,
  group_col,
  group_models,
  obs_filter,
  sort_col,
  sort_descending,
  pred_col,
  upper_col,
  lower_col,
  filter_na,
  ret
)
}
\arguments{
\item{df}{Data frame of model data.}

\item{forecast_function}{An R function that outputs a forecast object coming from the
forecast package. You can directly pass \code{\link[forecast:forecast]{forecast::forecast()}} to the
function, or you can pass other wrappers to it such as \code{\link[forecast:ses]{forecast::holt()}} or
\code{\link[forecast:ses]{forecast::ses()}}.}

\item{response}{Column name of response variable to be used as the input to the
forecast function.}

\item{...}{Additional arguments passed to the forecast function.}

\item{test_col}{Name of logical column specifying which response values to remove
for testing the model's predictive accuracy. If \code{NULL}, ignored. See \code{\link[=model_error]{model_error()}}
for details on the methods and metrics returned.}

\item{group_col}{Column name(s) of group(s) to use in \code{\link[dplyr:group_by]{dplyr::group_by()}} when
supplying type, calculating mean absolute scaled error on data involving
time series, and if \code{group_models}, then fitting and predicting models too.
If \code{NULL}, not used. Defaults to \code{"iso3"}.}

\item{group_models}{Logical, if \code{TRUE}, fits and predicts models individually onto
each \code{group_col}. If \code{FALSE}, a general model is fit across the entire data
frame.}

\item{obs_filter}{String value of the form "\verb{logical operator} \code{integer}"
that specifies the number of observations required to fit the model and
replace observations with predicted values. This is done in
conjunction with \code{group_col}. So, if \code{group_col = "iso3"} and
\code{obs_filter = ">= 5"}, then for this model, predictions will only be used
for \code{iso3} vales that have 5 or more observations. Possible logical operators
to use are \code{>}, \code{>=}, \code{<}, \code{<=}, \code{==}, and \code{!=}.}

\item{sort_col}{Column name of column to arrange data by in \code{dplyr::arrange()},
prior to filtering for latest contiguous time series and producing the
forecast. Not used if \code{NULL}, defaults to \code{"year"}.}

\item{sort_descending}{Logical value on whether the sorted values from \code{sort_col}
should be sorted in descending order. Defaults to \code{FALSE}.}

\item{pred_col}{Column name to store predicted value.}

\item{upper_col}{Column name to store upper bound of confidence interval.}

\item{lower_col}{Column name to store lower bound of confidence interval.}

\item{filter_na}{Character value specifying how, if at all, to filter \code{NA}
values from the dataset prior to applying the model.  By default, all
observations with missing values are removed, although it can also remove
rows only if they have missing dependent or independent variables, or no
filtering at all.}

\item{ret}{Character vector specifying what values the function returns. Defaults
to returning a data frame, but can return a vector of model error, the
model itself or a list with all 3 as components.}
}
\value{
List of \code{mdl} (fitted model) and \code{df} (data frame with fitted values
and confidence bounds generated from the model).
}
\description{
Used within \code{predict_forecast()}, this function fits the model to the data
frame, working whether the model is being fit across the entire data frame or
being fit to each group individually. Data is filtered prior to fitting,
model(s) are fit, and then fitted values are generated on the original.
}
\details{
If fitting models individually to each group, \code{mdl} will never be returned, as
as these are instead a large list of models. Otherwise, a list of \code{mdl} and \code{df}
is returned and used within \code{predict_inla()}.
}
